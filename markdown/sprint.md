# Spring 框架

## spring 框架的概述以及 spring 中基于 XML 的 IOC 配置

### spring 的概述

- spring 是什么
  - Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。
- spring 的两大核心
  - IoC（Inverse Of Control：反转控制）
  - AOP（Aspect Oriented Programming：面向切面编程）
- spring 的发展历程和优势
  - 优势
    - 方便解耦，简化开发
    - AOP 编程的支持
    - 声明式事务的支持
    - 方便程序的测试
    - 方便集成各种优秀框架
    - 降低 JavaEE API 的使用难度
    - Java 源码是经典学习范例
- spring 体系结构
  ![srping的体系结构](resource/SpringFramework.png)

### 程序的耦合及解耦

> 耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。

#### 耦合性的概念

耦合性（Coupling），也叫耦合度，是**对模块间关联程度的度量**。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差（降低耦合性，可以提高其独立性）。

在软件工程中，耦合指的就是就是**对象之间的依赖性**。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。

> 划分模块的一个准则就是高内聚低耦合。

#### 耦合的分类

- 内容耦合
  - 当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。
  - 内容耦合是最高程度的耦合，应该避免使用之。
- 公共耦合
  - 两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。
  - 在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。
- 外部耦合
  - 一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。
- 控制耦合
  - 一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。
- 标记耦合
  - 若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间存在一个标记耦合。
- 数据耦合
  - 模块之间通过参数来传递数据，那么被称为数据耦合。
  - 数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。
- 非直接耦合
  - 两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。

#### 内聚与耦合

内聚标志**一个模块内各个元素彼此结合的紧密程度**，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它**描述的是模块内的功能联系**。耦合是软件结构中各模块之间相互连接的一种度量，**耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据**。 程序讲究的是**低耦合，高内聚**。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。

内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。

#### 工厂模式解耦

在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。

这个读取配置文件，创建和获取三层对象的类就是工厂。

### IOC 的概念和 Spring 中的 IOC

#### IOC 的概念

> 控制反转(Inversion of Control， IOC)把创建对象的权力交给框架，是框架的重要特性，并非面向对象编程的专用术语。
> 包括依赖注入(Dependency injection, DI)和依赖查找(Dependency Lookup)

#### IOC 的作用

削减计算机程序的耦合(解除我们代码中的依赖关系)

#### spring 中基于 XML 的 IOC 环境搭建

##### bean 标签

- 作用
  - 用于配置对象让 spring 来创建的。
  - 默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。
- 属性：
  - id：给对象在容器中提供一个唯一标识。用于获取对象。
  - class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。
  - scope：指定对象的作用范围。
    - singleton :默认值，单例的.
    - prototype :多例的.
    - request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中.
    - session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中.
    - global session :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么 globalSession 相当于 session.
  - init-method：指定类中的初始化方法名称。
  - destroy-method：指定类中销毁方法名称。

##### bean 的作用范围和生命周期

- 单例对象：scope="singleton"
  - 作用范围：
    - 一个应用只有一个对象的实例。它的作用范围就是整个引用。
  - 生命周期
    - 对象出生：当应用加载，创建容器时，对象就被创建了。
    - 对象活着：只要容器在，对象一直活着。
    - 对象死亡：当应用卸载，销毁容器时，对象就被销毁了。
- 多例对象：scope="prototype"
  - 作用范围：
    - 每次访问对象时，都会重新创建对象实例
  - 生命周期：
    - 对象出生：当使用对象时，创建新的对象实例。
    - 对象活着：只要对象在使用中，就一直活着。
    - 对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。

### 依赖注入（Dependency Injection）

#### 依赖注入的概念

依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现。
我们的程序在编写时，通过控制反转，把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况。ioc 解耦只是降低他们的依赖关系，但不会消除。例如：我们的业务层仍会调用持久层的方法。
那这种业务层和持久层的依赖关系，在使用 spring 之后，就让 spring 来维护了。
简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。

#### 构造函数注入

#### set 方法注入

#### 使用 p 名称空间注入数据（本质还是调用 set 方法）

#### 注入集合属性

##### List 结构的

- array
- list
- set

##### Map 结构的

- map
- entry
- props
- prop

## spring 中基于注解的 IOC 的 ioc 的案例

## spring 中的 aop 和基于 XML 以及注解的 AOP 配置

## spring 中的 jdbcTemplate 以及 Spring 事务控制
